package Review;

public class Threada {

	public static void main(String[] args) {
		//了解 进程和线程的关系
		
		/* 进程  
		 * 一个应用程序只能有一个线程
		 * 通过多个线程占据系统资源
		 * 进程之间数据状态完全独立
		 */
		
		/* 线程
		 * 一个进程可以包括多个线程
		 * 线程是执行程序的最小单元
		 * 占用cpu的基本单位
		 * 线程间共享一块内存
		 */
		
		//线程完整的生命周期包括五个状态：新建、就绪、运行、阻塞和死亡.

		//继承Thread类
		
		/*
		 * 重写 run()方法 
		 * 需要访问当前的线程直接用this即可
		 */
		
		//继承Runnable 接口
		/*
		 * 重写run()方法
		 * 访问当前的线程需要使用 静态方法 Thread.currentThread()
		 */
		/*
		 * start():启动线程，让线程从新建状态进入就绪队列排队;
		 * run():线程对象被调度之后所执行的操作;
		 * sleep():暂停线程的执行，让当前线程休眠若干毫秒;//静态方法 
		 * currentThread():返回对当前正在执行的线程对象的引用;
		 * isAlive():测试线程的状态，新建、死亡状态的线程返回false; 
		 * interrupt():“吵醒”休眠的线程，唤醒“自己”;
		 * yield():暂停正在执行的线程，让同等优先级的线程运行; //静态方法
		 * join():当前线程等待调用该方法的线程结束后，再排队等待CPU资源;
		 * stop():终止线程.
		 */
		//由synchronized修饰的类或者方法在一段时间内只允许一个线程访问

	}

}
